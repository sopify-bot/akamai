# akamai
如何破盾，如何破akamai,如何破Nike akamai,如何耐克过盾，耐克如何过盾，nike如何过盾,nike 如何过阿卡迈,x-acf-sensor-data，
------
<<<<<<
****本人为唯一软件作者，**
<<<<<<紧急声明，紧急声明，紧急声明

有人拿我的软件源码，去骗人，听说骗了不少人；请大家一定注意；

   我就只有这一个QQ号，微信也是同号，这个人的跟我的号很像，名字也叫的差不多。请大家一定要弄清楚。
   我曝光一下这个骗子的的微信：Eadro-
   我就只有这一个QQ号，微信也是同号，这个人的跟我的号很像，名字也叫的差不多。请大家一定要弄清楚。
   我曝光一下这个骗子的的微信：Eadro-
   我就只有这一个QQ号，微信也是同号，这个人的跟我的号很像，名字也叫的差不多。请大家一定要弄清楚。
   我曝光一下这个骗子的的微信：Eadro-
   我就只有这一个QQ号，微信也是同号，这个人的跟我的号很像，名字也叫的差不多。请大家一定要弄清楚。
   我曝光一下这个骗子的的微信：Eadro-
   我就只有这一个QQ号，微信也是同号，这个人的跟我的号很像，名字也叫的差不多。请大家一定要弄清楚。
   我曝光一下这个骗子的的微信：Eadro-
<<<<<<紧急声明，紧急声明，紧急声明

**本人为唯一软件作者,**
**本人为唯一软件作者**
  **近期发现有人专卖，我的源码拿来骗人，甚是可恨。区别很简单，我是原作者能过盾，如果他说他是原作者，你让他过盾试试。**
  唯一联系QQ:80258153 唯一联系QQ:80258153**
>>>>>>>
10-30 app端akamai做了一些升级；
所以很早之前的老版本是没什么用了,所以我就拿出来分享分享。

但是反编译后发现 公钥还是一样的。
key="MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC4sA7vA7N/t1SRBS8tugM2X4bByl0jaCZLqxPOql+qZ3sP4UFayqJTvXjd7eTjMwg1T70PnmPWyh1hfQr4s12oSVphTKAjPiWmEBvcpnPPMjr5fGgv0w6+KM9DLTxcktThPZAGoVcoyM/cTO/YsAMIxlmTzpXBaxddHRwi8S2NvwIDAQAB";
----------
顺便晒一下这几天的单子
联系QQ:80258153

[root@vm10-0-0-26 2020-11-04]# grep 'orderN' info-log.log 
Thread-15587] INFO  nike.bot.SimpleBot - 任务ID<252759186>订单号为:orderNum:C00277612657
Thread-15690] INFO  nike.bot.SimpleBot - 任务ID<692815842>订单号为:orderNum:C00277648371
Thread-15736] INFO  nike.bot.SimpleBot - 任务ID<102793446>订单号为:orderNum:C00277651296
Thread-15788] INFO  nike.bot.SimpleBot - 任务ID<82542603>订单号为:orderNum:C00277663888
Thread-15797] INFO  nike.bot.SimpleBot - 任务ID<925809920>订单号为:orderNum:C00277663995
Thread-15804] INFO  nike.bot.SimpleBot - 任务ID<652856128>订单号为:orderNum:C00277667374
Thread-15888] INFO  nike.bot.SimpleBot - 任务ID<823797705>订单号为:orderNum:C00277682756
Thread-15904] INFO  nike.bot.SimpleBot - 任务ID<317854411>订单号为:orderNum:C00277684286
Thread-15936] INFO  nike.bot.SimpleBot - 任务ID<462733066>订单号为:orderNum:C00277682925
Thread-15959] INFO  nike.bot.SimpleBot - 任务ID<162654391>订单号为:orderNum:C00277684915
Thread-16125] INFO  nike.bot.SimpleBot - 任务ID<294222862>订单号为:orderNum:C00277737578
Thread-16232] INFO  nike.bot.SimpleBot - 任务ID<820870227>订单号为:orderNum:C00277748358
Thread-16262] INFO  nike.bot.SimpleBot - 任务ID<71133900>订单号为:orderNum:C00277752562
Thread-16273] INFO  nike.bot.SimpleBot - 任务ID<966133033>订单号为:orderNum:C00277755128
Thread-16309] INFO  nike.bot.SimpleBot - 任务ID<213904978>订单号为:orderNum:C00277773766
Thread-16318] INFO  nike.bot.SimpleBot - 任务ID<807674968>订单号为:orderNum:C00277778062
Thread-16435] INFO  nike.bot.SimpleBot - 任务ID<617705984>订单号为:orderNum:C00277799586
Thread-16439] INFO  nike.bot.SimpleBot - 任务ID<552067210>订单号为:orderNum:C00277802986
Thread-16486] INFO  nike.bot.SimpleBot - 任务ID<498336553>订单号为:orderNum:C00277804919
Thread-16487] INFO  nike.bot.SimpleBot - 任务ID<531699612>订单号为:orderNum:C00277806391
Thread-16502] INFO  nike.bot.SimpleBot - 任务ID<764914127>订单号为:orderNum:C00277811794
Thread-16556] INFO  nike.bot.SimpleBot - 任务ID<537854721>订单号为:orderNum:C00277817901
Thread-16621] INFO  nike.bot.SimpleBot - 任务ID<258198251>订单号为:orderNum:C00277823388
Thread-16704] INFO  nike.bot.SimpleBot - 任务ID<370192281>订单号为:orderNum:C00277829118
Thread-16791] INFO  nike.bot.SimpleBot - 任务ID<602004611>订单号为:orderNum:C00277839060
Thread-16914] INFO  nike.bot.SimpleBot - 任务ID<36852301>订单号为:orderNum:C00277844100
Thread-16954] INFO  nike.bot.SimpleBot - 任务ID<265224693>订单号为:orderNum:C00277857076
Thread-16983] INFO  nike.bot.SimpleBot - 任务ID<673960557>订单号为:orderNum:C00277862761
Thread-17036] INFO  nike.bot.SimpleBot - 任务ID<577380150>订单号为:orderNum:C00277863106
Thread-17079] INFO  nike.bot.SimpleBot - 任务ID<929621987>订单号为:orderNum:C00277870385
Thread-17080] INFO  nike.bot.SimpleBot - 任务ID<721141115>订单号为:orderNum:C00277871833
Thread-17083] INFO  nike.bot.SimpleBot - 任务ID<621885038>订单号为:orderNum:C00277873337
Thread-17124] INFO  nike.bot.SimpleBot - 任务ID<157880344>订单号为:orderNum:C00278182005
Thread-17125] INFO  nike.bot.SimpleBot - 任务ID<990221575>订单号为:orderNum:C00278179083
Thread-17126] INFO  nike.bot.SimpleBot - 任务ID<916299477>订单号为:orderNum:C00278184938
Thread-17462] INFO  nike.bot.SimpleBot - 任务ID<925686669>订单号为:orderNum:C00278290937
Thread-17465] INFO  nike.bot.SimpleBot - 任务ID<141374181>订单号为:orderNum:C00278295611
Thread-17518] INFO  nike.bot.SimpleBot - 任务ID<910614314>订单号为:orderNum:C00278299159
Thread-17520] INFO  nike.bot.SimpleBot - 任务ID<497660940>订单号为:orderNum:C00278300625
Thread-17531] INFO  nike.bot.SimpleBot - 任务ID<930879443>订单号为:orderNum:C00278297694
Thread-17561] INFO  nike.bot.SimpleBot - 任务ID<225431449>订单号为:orderNum:C00278305882
Thread-17567] INFO  nike.bot.SimpleBot - 任务ID<82598806>订单号为:orderNum:C00278311739
Thread-17568] INFO  nike.bot.SimpleBot - 任务ID<729931861>订单号为:orderNum:C00278312725
Thread-17592] INFO  nike.bot.SimpleBot - 任务ID<401877978>订单号为:orderNum:C00278310395
Thread-17614] INFO  nike.bot.SimpleBot - 任务ID<514422158>订单号为:orderNum:C00278315722
Thread-17685] INFO  nike.bot.SimpleBot - 任务ID<612288996>订单号为:orderNum:C00278341468
Thread-17729] INFO  nike.bot.SimpleBot - 任务ID<545859874>订单号为:orderNum:C00278346462
Thread-17752] INFO  nike.bot.SimpleBot - 任务ID<502799010>订单号为:orderNum:C00278354810
Thread-17836] INFO  nike.bot.SimpleBot - 任务ID<614744743>订单号为:orderNum:C00278395230
Thread-17914] INFO  nike.bot.SimpleBot - 任务ID<563983773>订单号为:orderNum:C00278404221
Thread-17945] INFO  nike.bot.SimpleBot - 任务ID<562000585>订单号为:orderNum:C00278402028
Thread-17977] INFO  nike.bot.SimpleBot - 任务ID<182757980>订单号为:orderNum:C00278411435
Thread-18002] INFO  nike.bot.SimpleBot - 任务ID<417280274>订单号为:orderNum:C00278417556
Thread-18135] INFO  nike.bot.SimpleBot - 任务ID<55704787>订单号为:orderNum:C00278459925
Thread-18178] INFO  nike.bot.SimpleBot - 任务ID<333597568>订单号为:orderNum:C00278470787
Thread-18232] INFO  nike.bot.SimpleBot - 任务ID<433963527>订单号为:orderNum:C00278479678
Thread-18290] INFO  nike.bot.SimpleBot - 任务ID<775640118>订单号为:orderNum:C00278495534
Thread-18333] INFO  nike.bot.SimpleBot - 任务ID<610080575>订单号为:orderNum:C00278496452
Thread-18375] INFO  nike.bot.SimpleBot - 任务ID<864264272>订单号为:orderNum:C00278512570
Thread-18400] INFO  nike.bot.SimpleBot - 任务ID<153437328>订单号为:orderNum:C00278513833
Thread-18481] INFO  nike.bot.SimpleBot - 任务ID<324618436>订单号为:orderNum:C00278536589
Thread-18494] INFO  nike.bot.SimpleBot - 任务ID<81779954>订单号为:orderNum:C00278536099
Thread-18502] INFO  nike.bot.SimpleBot - 任务ID<558904918>订单号为:orderNum:C00278543909
Thread-18528] INFO  nike.bot.SimpleBot - 任务ID<592867487>订单号为:orderNum:C00278554567
Thread-18547] INFO  nike.bot.SimpleBot - 任务ID<384519254>订单号为:orderNum:C00278554120
Thread-18675] INFO  nike.bot.SimpleBot - 任务ID<797823918>订单号为:orderNum:C00278574458
Thread-18706] INFO  nike.bot.SimpleBot - 任务ID<228659361>订单号为:orderNum:C00278575012
Thread-18716] INFO  nike.bot.SimpleBot - 任务ID<865206643>订单号为:orderNum:C00278580652
Thread-18715] INFO  nike.bot.SimpleBot - 任务ID<210565368>订单号为:orderNum:C00278580658
Thread-18720] INFO  nike.bot.SimpleBot - 任务ID<314094394>订单号为:orderNum:C00278580169
Thread-19076] INFO  nike.bot.SimpleBot - 任务ID<773316591>订单号为:orderNum:C00278828503
Thread-19077] INFO  nike.bot.SimpleBot - 任务ID<457333738>订单号为:orderNum:C00278825587
Thread-19078] INFO  nike.bot.SimpleBot - 任务ID<835587740>订单号为:orderNum:C00278831396
Thread-19082] INFO  nike.bot.SimpleBot - 任务ID<166217221>订单号为:orderNum:C00278831398
Thread-19083] INFO  nike.bot.SimpleBot - 任务ID<775765657>订单号为:orderNum:C00278831400
Thread-19127] INFO  nike.bot.SimpleBot - 任务ID<966080760>订单号为:orderNum:C00278841587
Thread-19152] INFO  nike.bot.SimpleBot - 任务ID<994603774>订单号为:orderNum:C00278839243
Thread-19178] INFO  nike.bot.SimpleBot - 任务ID<826382221>订单号为:orderNum:C00278846581
Thread-19200] INFO  nike.bot.SimpleBot - 任务ID<6429190>订单号为:orderNum:C00278844173
Thread-19218] INFO  nike.bot.SimpleBot - 任务ID<872914032>订单号为:orderNum:C00278852160
Thread-19266] INFO  nike.bot.SimpleBot - 任务ID<671918133>订单号为:orderNum:C00278849800
Thread-19339] INFO  nike.bot.SimpleBot - 任务ID<587588268>订单号为:orderNum:C00278856727
----------
package nike.akamai;


import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.Mac;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.security.Key;
import java.security.KeyFactory;
import java.security.PublicKey;
import java.security.spec.X509EncodedKeySpec;
import java.util.Random;
import java.util.UUID;

import static nike.akamai.DeviceInfo.randomScreenSize;

public class AKAMAI {
    static  long uptime=0;
    static long startTime=System.currentTimeMillis();
    public  AKAMAI(){
        uptime=(nike.common.tool.Math.romdom(0,12))*36;
    }

    public long getUptime(){
        Long S=uptime+(System.currentTimeMillis()-startTime);
        return 0;
    }

    //模拟手机信息
   public DeviceInfo mDeviceInfo=new DeviceInfo("");

    SecretKey aesKey = null;
    SecretKey hmacKey = null;
    String aesKeyEncrypted = null;
    String hamcKeyEncryped = null;

    public String getClientInfo(){
       return mDeviceInfo.getClientInfo();
    }

    private String appUserAgent() {
        return "NikePlus/2.130.0 (com.nike.omega; build:2009171834; iOS 14.0.0) Alamofire/5.1.0";
    }




    public String getSensorData(String email) {
        mDeviceInfo=new DeviceInfo(email);
        String model = mDeviceInfo.model;
        String androidVersion = mDeviceInfo.androidVersion;
        String brand = mDeviceInfo.brand;
        Random random = new Random();
        StringBuilder stringBuilder6 = new StringBuilder();
        stringBuilder6
                .append("2.2.1-1,2,-94,-100,")
                .append("-1,uaend,-1,")
                .append(randomScreenSize())
                .append(",1,100,1,zh,")
                .append(androidVersion).append(",0,")
                .append(brand)
                .append(",unknown,qcom,-1,com.nike.snkrs,-1,-1,")
                .append(UUID.randomUUID().toString())
                .append(",-1,0,1,REL,")
                .append(208).append(",23,")
                .append(brand).append(",").append(brand).append(",release-keys,user,sysop,")
                .append(model).append(",").append(brand).append(",").append(brand).append(",").append(brand).append(",").append(brand).append("/").append(brand).append("/").append(brand)
                .append(":").append(androidVersion).append("/").append(model).append("/").append(208)
                .append(":user/release-keys,")
                .append("builder02,").append(model);
        int length = chrplus(stringBuilder6.toString());
        stringBuilder6.append(",").append(length).append(",").append(Math.max(1, random.nextInt(9999))).append(",").append(System.currentTimeMillis() / 2)
                .append("-1,2,-94,-101,")
                .append("do_unr,dm_en,t_en")
                .append("-1,2,-94,-102,")
                .append("-1,2,-94,-108,")
                .append("-1,2,-94,-117,")
                .append("-1,2,-94,-111,")
                .append("488,251.16,36.5,-1.78,1;237,258.35,44.35,-13.11,1;197,266.15,47.71,-23.78,1;198,278.47,49.24,-40.3,1;196,290.74,48.53,-55.62,1;200,303.92,43.47,-73.12,1;196,319.91,45.4,-85.75,1;197,320.26,43.32,-87.43,1;234,316.89,44.01,-84.71,1;160,324.08,46.81,-88.62,1;")
                .append("-1,2,-94,-109,")
                .append("330,-0.09,-2.19,-2.98,-0.23,-5.95,-8.1,16.29,-4.44,1.62,1;157,-0.17,-1.17,-1.08,-0.54,-6.44,-7.61,52.57,-37,27.78,1;237,-0.64,-0.65,-0.08,-1.74,-6.67,-6.7,111.33,-104.75,38.67,1;197,-0.83,-0.74,1.39,-2.94,-7.65,-3.57,23.57,-13.33,63.47,1;198,-1.2,-0.56,0.01,-4.66,-8.1,-4.94,16.88,-110.1,17.13,1;197,-0.6,-0.01,0.72,-4.71,-7.57,-3.45,18.99,-90.13,41.01,1;200,-1.38,0.94,0.99,-7.25,-6.14,-1.01,9.08,-110.71,70.58,1;196,-1.03,0.96,1.31,-7.95,-5.15,0.64,19.63,-87.92,-29.64,1;196,0.7,-0.13,1.23,-5.52,-6.38,1.8,-21.57,-14.16,22.13,1;235,-0.3,0.16,0.53,-6.81,-5.93,1.62,-52.49,-9.56,-12.3,1;")
                .append("-1,2,-94,-144,")
                .append("2;160.00;488.00;2291790394;}O3GH2GNAGHGH3GHGH4G2HGH2GH2GH2GHGH8GHGH7G2H3GHG")
                .append("-1,2,-94,-142,")
                .append("2;251.16;350.86;3976058770;AEJQX`2jhlo3q2rt2vw3xy2z11{14|}4|z_HECGTm:2;26.95;63.23;2779607165;P]ced._.]ade3f2g2h2i4k11j19k2jeLAMo}{:2;-105.99;-1.78;1915754872;}vpf]SLKMJI4HGF2E3D2C6B26ABVotyugO")
                .append("-1,2,-94,-145,")
                .append("2;157.00;330.00;3702715838;}A.NONO2N.BNONO2N2ON2O3N2ONONMP2NO2NON2ON2ONO2NOMPNO2NO2N2ONONO")
                .append("-1,2,-94,-143,")
                .append("2;-1.38;0.82;4185390251;daUOEVAJy^nmkigf2gfghehkfghefge7f4g15fgfw}tyo:2;-2.19;1.08;1351463476;AS][^i2zflcf2g7hi4h13ihih16inx}wZK:2;-4.96;2.41;87824826;Q`htioqtsmiklj7i2hihikj30ioJAUj}:2;-7.95;-0.23;756849891;}zqg2ZFASIL2N4O3PQPRTS2T7S3R4STST14SU^fgsr:2;-8.11;-3.97;2797807175;`YUGAH]kZ`2ONM4L2KJK2H2GHIH10I11H7IJRev}aA:2;-10.25;3.34;48988008;JLP^X_iqvuprt3sr4s2rsrsu13t18u}YABJ]:2;-210.32;192.99;3109801715;bhpcbcac]X2a2`_7`_2`2a30`aUAWl}o:2;-110.71;232.15;2476552013;SMBRADADQRO2SU5TUVR3SUTS11TS17T]}{beUF:2;-29.64;70.58;2886463249;Scix.k}A_KAJ2PRQP2Q3PKT2RS2RT4S2R3Q6RS2RSRS2R4SV_FXgfi")
                .append("-1,2,-94,-115,")
                .append("0,0,8671479250,17701151970,26372631220,15386,0,0,64,64,18000,116000,1,699084045103471958,1568251393817,0")
                .append("-1,2,-94,-106,")
                .append("-1,0")
                .append("-1,2,-94,-120,")
                .append("-1,2,-94,-112,")
                //o.n
                .append("19,2175,59,1068,288800,2896,22100,220,7846")
                .append("-1,2,-94,-103,");
        //System.out.println("oriSensorData:" + stringBuilder6);
        String sensor = encryptSensor(stringBuilder6.toString());
        return sensor;
    }


    private String  getSensor(){
        StringBuilder stringBuilder=new StringBuilder();
        return stringBuilder.toString();
    }



    public static int chrplus(String paramString) {
        if (paramString != null && !paramString.trim().equalsIgnoreCase("")) {
            int b = 0;
            int c = 0;
            try {
                while (b < paramString.length()) {
                    char c2 = paramString.charAt(b);
                    if (c2 < 128)
                        c = c + c2;
                    b++;
                }
                return c;
            } catch (Exception e) {
                return -2;
            }
        }
        return -1;
    }

    public String encryptSensor(String str) {
        String result = null;
        try {
            initEncryptKey();

            long uptimeMillis = getUptime();
            Cipher instance = Cipher.getInstance("AES/CBC/PKCS5Padding");
            instance.init(1, aesKey);
            byte[] doFinal = instance.doFinal(str.getBytes());
            long aesUptime = (getUptime() - uptimeMillis) * 1000;
            byte[] iv = instance.getIV();
            byte[] obj = new byte[(doFinal.length + iv.length)];
            System.arraycopy(iv, 0, obj, 0, iv.length);
            System.arraycopy(doFinal, 0, obj, iv.length, doFinal.length);
            uptimeMillis = getUptime();
            Key secretKeySpec = new SecretKeySpec(hmacKey.getEncoded(), "HmacSHA256");
            Mac instance2 = Mac.getInstance("HmacSHA256");
            instance2.init(secretKeySpec);
            iv = instance2.doFinal(obj);
            doFinal = new byte[(obj.length + iv.length)];
            long hmackUptime = (getUptime() - uptimeMillis) * 1000;
            System.arraycopy(obj, 0, doFinal, 0, obj.length);
            System.arraycopy(iv, 0, doFinal, obj.length, iv.length);
            uptimeMillis = getUptime();
            String encryptedData = Base64.encodeToString(doFinal, 2);
            long b64uptime = 1000 * (getUptime() - uptimeMillis);

            StringBuilder sb = new StringBuilder();
            sb.append("1,a,");
            sb.append(aesKeyEncrypted);
            sb.append(",");
            sb.append(hamcKeyEncryped);
            sb.append("$");
            sb.append(encryptedData);
            sb.append("$");
            sb.append(aesUptime).append(",").append(hmackUptime).append(",").append(b64uptime);
            result = sb.toString();
        } catch (Exception e) {
        }
        return result;
    }




    private void initEncryptKey() {
        if (aesKey != null) {
            return;
        }
        try {
            KeyGenerator keyGen = KeyGenerator.getInstance("AES");
            aesKey = keyGen.generateKey();

            KeyGenerator hmacKeyGen = KeyGenerator.getInstance("HmacSHA256");
            hmacKey = hmacKeyGen.generateKey();
            String key=null;
            key="MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC4sA7vA7N/t1SRBS8tugM2X4bByl0jaCZLqxPOql+qZ3sP4UFayqJTvXjd7eTjMwg1T70PnmPWyh1hfQr4s12oSVphTKAjPiWmEBvcpnPPMjr5fGgv0w6+KM9DLTxcktThPZAGoVcoyM/cTO/YsAMIxlmTzpXBaxddHRwi8S2NvwIDAQAB";
            X509EncodedKeySpec keySpec =new X509EncodedKeySpec(Base64.decode(key,0));

            KeyFactory factory = KeyFactory.getInstance("RSA");
            PublicKey rsaKey = factory.generatePublic(keySpec);

            Cipher rsaInstance = Cipher.getInstance("RSA/ECB/PKCS1PADDING");
            rsaInstance.init(1, rsaKey);
            aesKeyEncrypted = Base64.encodeToString(rsaInstance.doFinal(aesKey.getEncoded()), 2);
            hamcKeyEncryped = Base64.encodeToString(rsaInstance.doFinal(hmacKey.getEncoded()), 2);
        } catch (Exception e) {
        }
    }

    public static void main(String[] args) throws Exception {
        System.out.println(new AKAMAI().getSensorData(""));;
    }

}
-------------
package nike.akamai;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.security.MessageDigest;
import java.util.*;

import static nike.akamai.Utils.md5;

public class DeviceInfo {

    final static String[] ANDROID_SCREEN_SIZE = new String[]{"854,380"+nike.common.tool.Math.romdom(0,100), "1280,700"+nike.common.tool.Math.romdom(0,100), "2560,1500"+nike.common.tool.Math.romdom(0,100), "1920,900"+nike.common.tool.Math.romdom(0,100), "2560,1340"+nike.common.tool.Math.romdom(0,100), "1280,568"+nike.common.tool.Math.romdom(0,100), "1920,1100"+nike.common.tool.Math.romdom(0,100)};
    final static Map<String, String> ANDROID_VERSION = new HashMap<String, String>() {{
        put("6.0", "23");
        put("7.0", "24");
        put("7.1", "25");
        put("8.0.0", "26");
        put("8.1.0", "27");
        put("5.1", "22");
    }};
    final static String[] ANDROID_BRAND = new String[]{"samsung", "huawei", "TCL", "MEIZU", "Sony", "Lenovo", "OPPO", "vivo", "A7"};
    private static String[] ANDROID_MODEL = new String[]{"X820", "P20", "S10", "p30", "S8", "note7"};

    public String brand;
    public String model;
    public String androidVersion;
    public String SDKINT;
    private String username;

    public DeviceInfo(String username) {
        this.username=UUID.randomUUID().toString();
        //this.username = username;
        this.brand = randomANDROIDBRAND();
        this.model = randomANDROIDMODEL();
        this.androidVersion = randomANDROIDVERSION();
        this.SDKINT = ANDROID_VERSION.get(this.androidVersion);
    }

    private static String E(Map<String, String> paramMap) {
        StringBuilder stringBuilder = new StringBuilder();
        if (paramMap == null) {
            stringBuilder.append("0");
        } else {
            Formatter formatter = new Formatter(stringBuilder);
            formatter.format("%04x", new Object[]{Integer.valueOf(paramMap.size())});
            for (Map.Entry entry : paramMap.entrySet()) {
                a(formatter, (String) entry.getKey());
                a(formatter, (String) entry.getValue());
            }
        }
        return stringBuilder.toString();
    }

    private String getBluetoothAddress() {
        String blue = md5("blue" + username).substring(0, 12);
        StringBuilder sb = new StringBuilder();
        StringBuilder temp = new StringBuilder();
        for (char c : blue.toCharArray()) {
            if (temp.length() < 2) {
                temp.append(c);
            } else {
                sb.append(temp);
                temp.delete(0, temp.length());
            }
        }
        return sb.toString();
    }

    public String getClientInfo() {
        StringBuilder stringBuilder = new StringBuilder("0500");
        HashMap hashMap = new HashMap();
        b(hashMap, "BBSC", "Android");
        b(hashMap, "CLIENT_TIME", c());
        b(hashMap, "AFPID", getFinger());
        b(hashMap, "MACA", getMac(username));
        b(hashMap, "BMACA", getBluetoothAddress());
        b(hashMap, "ASL", SDKINT);
        b(hashMap, "ABN", model);
//            a(hashMap);
        b(hashMap, "ANID", getImei());
        b(hashMap, "AMID", getAndroidId());
        b(hashMap, "ADSV", androidVersion);
        b(hashMap, "ADM", model);
        b(hashMap, "ADLO", getISO3Country());
        stringBuilder.append(a(E(hashMap)));
        return stringBuilder.toString();
    }

    private static String a(String paramString) {
        if (paramString != null)
            try {
                return ac(paramString.getBytes("utf-8"));
            } catch (IOException e) {
            }
        return "";
    }

    private static String a(byte[] paramArrayOfByte) {
        try {
            MessageDigest messageDigest = MessageDigest.getInstance("MD5");
            messageDigest.update(paramArrayOfByte);
            paramArrayOfByte = messageDigest.digest();
            StringBuffer stringBuffer = new StringBuffer();
            for (byte b = 0; b < paramArrayOfByte.length; b++)
                stringBuffer.append(Integer.toHexString(paramArrayOfByte[b] & 0xFF));
            return stringBuffer.toString();
        } catch (Throwable a) {
            return null;
        }
    }

    private static void a(Formatter paramFormatter, String paramString) {
        paramFormatter.format("%04x", new Object[]{Integer.valueOf(paramString.length())});
        paramFormatter.format("%s", new Object[]{paramString});
    }

    private static String ac(byte[] paramArrayOfByte) {
        try {
            int i;
            byte[] arrayOfByte2 = new byte[16];
            (new Random()).nextBytes(arrayOfByte2);
            ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
            byteArrayOutputStream.write("0500".getBytes());
            byteArrayOutputStream.write(paramArrayOfByte);
            if (byteArrayOutputStream.size() % 16 == 0) {
                i = 0;
            } else {
                i = 16 - byteArrayOutputStream.size() % 16;
            }
            byteArrayOutputStream.write(new byte[]{
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0}, 0, i);
            Cipher cipher = Cipher.getInstance("AES/CBC/NoPadding");
            IvParameterSpec ivParameterSpec = new IvParameterSpec(arrayOfByte2);
            cipher.init(1, new SecretKeySpec(new byte[]{
                    16, -59, 20, -5, -54, -85, 110, 61, -51, -99,
                    70, -78, 11, -44, 3, 5, -120, 58, -14, 74,
                    13, -122, 35, 120, 14, -60, 67, 73, -58, -90,
                    42, 112}, "AES"), ivParameterSpec);
            byte[] arrayOfByte1 = cipher.doFinal(byteArrayOutputStream.toByteArray());
            byteArrayOutputStream = new ByteArrayOutputStream();
            byteArrayOutputStream.write(arrayOfByte2);
            byteArrayOutputStream.write(arrayOfByte1);
            return new String(ad(byteArrayOutputStream.toByteArray()));
        } catch (Throwable e) {
            e.printStackTrace();
            return "";
        }
    }

    private static byte[] ad(byte[] bArr) {
        byte[] bArr2 = new byte[]{(byte) 65, (byte) 66, (byte) 67, (byte) 68, (byte) 69, (byte) 70, (byte) 71, (byte) 72, (byte) 73, (byte) 74, (byte) 75, (byte) 76, (byte) 77, (byte) 78, (byte) 79, (byte) 80, (byte) 81, (byte) 82, (byte) 83, (byte) 84, (byte) 85, (byte) 86, (byte) 87, (byte) 88, (byte) 89, (byte) 90, (byte) 97, (byte) 98, (byte) 99, (byte) 100, (byte) 101, (byte) 102, (byte) 103, (byte) 104, (byte) 105, (byte) 106, (byte) 107, (byte) 108, (byte) 109, (byte) 110, (byte) 111, (byte) 112, (byte) 113, (byte) 114, (byte) 115, (byte) 116, (byte) 117, (byte) 118, (byte) 119, (byte) 120, (byte) 121, (byte) 122, (byte) 48, (byte) 49, (byte) 50, (byte) 51, (byte) 52, (byte) 53, (byte) 54, (byte) 55, (byte) 56, (byte) 57, (byte) 43, (byte) 47};
        if (bArr != null) {
            int length = bArr.length;
            if (length != 0) {
                int i;
                int i2 = length / 3;
                int i3 = 0;
                byte[] bArr3 = new byte[(((length % 3 != 0 ? 1 : 0) + i2) * 4)];
                int i4 = 0;
                int i5 = 0;
                while (i3 < i2) {
                    i = i4 + 1;
                    int i6 = i + 1;
                    i4 = ((bArr[i4] & 255) << 16) | ((bArr[i] & 255) << 8);
                    i = i6 + 1;
                    i4 |= bArr[i6] & 255;
                    i6 = i5 + 1;
                    bArr3[i5] = bArr2[(i4 >> 18) & 63];
                    i5 = i6 + 1;
                    bArr3[i6] = bArr2[(i4 >> 12) & 63];
                    i6 = i5 + 1;
                    bArr3[i5] = bArr2[(i4 >> 6) & 63];
                    i5 = i6 + 1;
                    bArr3[i6] = bArr2[i4 & 63];
                    i3++;
                    i4 = i;
                }
                i2 *= 3;
                if (i2 < length) {
                    i3 = i4 + 1;
                    i4 = (bArr[i4] & 255) << 16;
                    i = i5 + 1;
                    bArr3[i5] = bArr2[(i4 >> 18) & 63];
                    int i7;
                    if (i2 + 1 < length) {
                        i7 = ((bArr[i3] & 255) << 8) | i4;
                        length = i + 1;
                        bArr3[i] = bArr2[(i7 >> 12) & 63];
                        i2 = length + 1;
                        bArr3[length] = bArr2[(i7 >> 6) & 63];
                    } else {
                        i7 = i + 1;
                        bArr3[i] = bArr2[(i4 >> 12) & 63];
                        i2 = i7 + 1;
                        bArr3[i7] = (byte) 61;
                    }
                    bArr3[i2] = (byte) 61;
                }
                return bArr3;
            }
        }
        return null;
    }

    private String getFinger() {
        try {
            StringBuilder sb = new StringBuilder();
            sb.append(brand).append("/").append(brand).append("/").append(brand)
                    .append(":").append(androidVersion).append("/").append(model).append("/").append(208)
                    .append(":user/release-keys");
            return md5(sb.toString());
        } catch (Throwable throwable) {
            return null;
        }
    }

    private String getISO3Country() {
        return "CHN";
    }

    private static void b(Map paramMap, String paramString1, String paramString2) {
        if (paramString1 != null && paramString2 != null && paramString2.length() > 0)
            paramMap.put(paramString1, paramString2);
    }

    private static String c() {
        try {
            Calendar calendar = Calendar.getInstance(TimeZone.getTimeZone("UTC"));
            return String.format("%04d %02d %02d %02d:%02d:%02d.%03d", new Object[]{Integer.valueOf(calendar.get(1)), Integer.valueOf(calendar.get(2) + 1), Integer.valueOf(calendar.get(5)), Integer.valueOf(calendar.get(11)), Integer.valueOf(calendar.get(12)), Integer.valueOf(calendar.get(13)), Integer.valueOf(calendar.get(14))});
        } catch (Throwable throwable) {
            return null;
        }
    }

    private static String getMac(String data) {
        String mac = md5("mac" + data).substring(0, 12);
        StringBuilder sb = new StringBuilder();
        StringBuilder temp = new StringBuilder();
        for (char c : mac.toCharArray()) {
            if (temp.length() < 2) {
                temp.append(c);
            } else {
                sb.append(temp);
                temp.delete(0, temp.length());
            }
        }
        return sb.toString();
    }


    private String getImei() {
        return md5("imei" + username).substring(0, 16);
    }

    private String getAndroidId() {
        return md5("android" + username).substring(0, 16);
    }

    public static String randomScreenSize() {

        return ANDROID_SCREEN_SIZE[(int) (Math.random() * ANDROID_SCREEN_SIZE.length)];
    }

    public static String randomANDROIDVERSION() {
        Object[] versions = ANDROID_VERSION.keySet().toArray();

        return versions[(int) (Math.random() * versions.length)].toString();
    }

    public static String randomANDROIDBRAND() {

        return ANDROID_BRAND[(int) (Math.random() * ANDROID_BRAND.length)];
    }

    public static String randomANDROIDMODEL() {

        return ANDROID_MODEL[(int) (Math.random() * ANDROID_MODEL.length)];
    }
}
------------
/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package nike.akamai;

import android.util.Base64OutputStream;

import java.io.UnsupportedEncodingException;

/**
 * Utilities for encoding and decoding the Base64 representation of
 * binary data.  See RFCs <a
 * href="http://www.ietf.org/rfc/rfc2045.txt">2045</a> and <a
 * href="http://www.ietf.org/rfc/rfc3548.txt">3548</a>.
 */
public class Base64 {
    /**
     * Default values for encoder/decoder flags.
     */
    public static final int DEFAULT = 0;

    /**
     * Encoder flag bit to omit the padding '=' characters at the end
     * of the output (if any).
     */
    public static final int NO_PADDING = 1;

    /**
     * Encoder flag bit to omit all line terminators (i.e., the output
     * will be on one long line).
     */
    public static final int NO_WRAP = 2;

    /**
     * Encoder flag bit to indicate lines should be terminated with a
     * CRLF pair instead of just an LF.  Has no effect if {@code
     * NO_WRAP} is specified as well.
     */
    public static final int CRLF = 4;

    /**
     * Encoder/decoder flag bit to indicate using the "URL and
     * filename safe" variant of Base64 (see RFC 3548 section 4) where
     * {@code -} and {@code _} are used in place of {@code +} and
     * {@code /}.
     */
    public static final int URL_SAFE = 8;

    /**
     * Flag to pass to {@link Base64OutputStream} to indicate that it
     * should not close the output stream it is wrapping when it
     * itself is closed.
     */
    public static final int NO_CLOSE = 16;

    //  --------------------------------------------------------
    //  shared code
    //  --------------------------------------------------------

    /* package */ static abstract class Coder {
        public byte[] output;
        public int op;

        /**
         * Encode/decode another block of input data.  this.output is
         * provided by the caller, and must be big enough to hold all
         * the coded data.  On exit, this.opwill be set to the length
         * of the coded data.
         *
         * @param finish true if this is the final call to process for
         *        this object.  Will finalize the coder state and
         *        include any final bytes in the output.
         *
         * @return true if the input so far is good; false if some
         *         error has been detected in the input stream..
         */
        public abstract boolean process(byte[] input, int offset, int len, boolean finish);

        /**
         * @return the maximum number of bytes a call to process()
         * could produce for the given number of input bytes.  This may
         * be an overestimate.
         */
        public abstract int maxOutputSize(int len);
    }

    //  --------------------------------------------------------
    //  decoding
    //  --------------------------------------------------------

    /**
     * Decode the Base64-encoded data in input and return the data in
     * a new byte array.
     *
     * <p>The padding '=' characters at the end are considered optional, but
     * if any are present, there must be the correct number of them.
     *
     * @param str    the input String to decode, which is converted to
     *               bytes using the default charset
     * @param flags  controls certain features of the decoded output.
     *               Pass {@code DEFAULT} to decode standard Base64.
     *
     * @throws IllegalArgumentException if the input contains
     * incorrect padding
     */
    public static byte[] decode(String str, int flags) {
        return decode(str.getBytes(), flags);
    }

    /**
     * Decode the Base64-encoded data in input and return the data in
     * a new byte array.
     *
     * <p>The padding '=' characters at the end are considered optional, but
     * if any are present, there must be the correct number of them.
     *
     * @param input the input array to decode
     * @param flags  controls certain features of the decoded output.
     *               Pass {@code DEFAULT} to decode standard Base64.
     *
     * @throws IllegalArgumentException if the input contains
     * incorrect padding
     */
    public static byte[] decode(byte[] input, int flags) {
        return decode(input, 0, input.length, flags);
    }

    /**
     * Decode the Base64-encoded data in input and return the data in
     * a new byte array.
     *
     * <p>The padding '=' characters at the end are considered optional, but
     * if any are present, there must be the correct number of them.
     *
     * @param input  the data to decode
     * @param offset the position within the input array at which to start
     * @param len    the number of bytes of input to decode
     * @param flags  controls certain features of the decoded output.
     *               Pass {@code DEFAULT} to decode standard Base64.
     *
     * @throws IllegalArgumentException if the input contains
     * incorrect padding
     */
    public static byte[] decode(byte[] input, int offset, int len, int flags) {
        // Allocate space for the most data the input could represent.
        // (It could contain less if it contains whitespace, etc.)
        Decoder decoder = new Decoder(flags, new byte[len*3/4]);

        if (!decoder.process(input, offset, len, true)) {
            throw new IllegalArgumentException("bad base-64");
        }

        // Maybe we got lucky and allocated exactly enough output space.
        if (decoder.op == decoder.output.length) {
            return decoder.output;
        }

        // Need to shorten the array, so allocate a new one of the
        // right size and copy.
        byte[] temp = new byte[decoder.op];
        System.arraycopy(decoder.output, 0, temp, 0, decoder.op);
        return temp;
    }

    /* package */ static class Decoder extends Coder {
        /**
         * Lookup table for turning bytes into their position in the
         * Base64 alphabet.
         */
        private static final int DECODE[] = {
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
            -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
            -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
            41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        };

        /**
         * Decode lookup table for the "web safe" variant (RFC 3548
         * sec. 4) where - and _ replace + and /.
         */
        private static final int DECODE_WEBSAFE[] = {
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1,
            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
            -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63,
            -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
            41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        };

        /** Non-data values in the DECODE arrays. */
        private static final int SKIP = -1;
        private static final int EQUALS = -2;

        /**
         * States 0-3 are reading through the next input tuple.
         * State 4 is having read one '=' and expecting exactly
         * one more.
         * State 5 is expecting no more data or padding characters
         * in the input.
         * State 6 is the error state; an error has been detected
         * in the input and no future input can "fix" it.
         */
        private int state;   // state number (0 to 6)
        private int value;

        final private int[] alphabet;

        public Decoder(int flags, byte[] output) {
            this.output = output;

            alphabet = ((flags & URL_SAFE) == 0) ? DECODE : DECODE_WEBSAFE;
            state = 0;
            value = 0;
        }

        /**
         * @return an overestimate for the number of bytes {@code
         * len} bytes could decode to.
         */
        public int maxOutputSize(int len) {
            return len * 3/4 + 10;
        }

        /**
         * Decode another block of input data.
         *
         * @return true if the state machine is still healthy.  false if
         *         bad base-64 data has been detected in the input stream.
         */
        public boolean process(byte[] input, int offset, int len, boolean finish) {
            if (this.state == 6) return false;

            int p = offset;
            len += offset;

            // Using local variables makes the decoder about 12%
            // faster than if we manipulate the member variables in
            // the loop.  (Even alphabet makes a measurable
            // difference, which is somewhat surprising to me since
            // the member variable is final.)
            int state = this.state;
            int value = this.value;
            int op = 0;
            final byte[] output = this.output;
            final int[] alphabet = this.alphabet;

            while (p < len) {
                // Try the fast path:  we're starting a new tuple and the
                // next four bytes of the input stream are all data
                // bytes.  This corresponds to going through states
                // 0-1-2-3-0.  We expect to use this method for most of
                // the data.
                //
                // If any of the next four bytes of input are non-data
                // (whitespace, etc.), value will end up negative.  (All
                // the non-data values in decode are small negative
                // numbers, so shifting any of them up and or'ing them
                // together will result in a value with its top bit set.)
                //
                // You can remove this whole block and the output should
                // be the same, just slower.
                if (state == 0) {
                    while (p+4 <= len &&
                           (value = ((alphabet[input[p] & 0xff] << 18) |
                                     (alphabet[input[p+1] & 0xff] << 12) |
                                     (alphabet[input[p+2] & 0xff] << 6) |
                                     (alphabet[input[p+3] & 0xff]))) >= 0) {
                        output[op+2] = (byte) value;
                        output[op+1] = (byte) (value >> 8);
                        output[op] = (byte) (value >> 16);
                        op += 3;
                        p += 4;
                    }
                    if (p >= len) break;
                }

                // The fast path isn't available -- either we've read a
                // partial tuple, or the next four input bytes aren't all
                // data, or whatever.  Fall back to the slower state
                // machine implementation.

                int d = alphabet[input[p++] & 0xff];

                switch (state) {
                case 0:
                    if (d >= 0) {
                        value = d;
                        ++state;
                    } else if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;

                case 1:
                    if (d >= 0) {
                        value = (value << 6) | d;
                        ++state;
                    } else if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;

                case 2:
                    if (d >= 0) {
                        value = (value << 6) | d;
                        ++state;
                    } else if (d == EQUALS) {
                        // Emit the last (partial) output tuple;
                        // expect exactly one more padding character.
                        output[op++] = (byte) (value >> 4);
                        state = 4;
                    } else if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;

                case 3:
                    if (d >= 0) {
                        // Emit the output triple and return to state 0.
                        value = (value << 6) | d;
                        output[op+2] = (byte) value;
                        output[op+1] = (byte) (value >> 8);
                        output[op] = (byte) (value >> 16);
                        op += 3;
                        state = 0;
                    } else if (d == EQUALS) {
                        // Emit the last (partial) output tuple;
                        // expect no further data or padding characters.
                        output[op+1] = (byte) (value >> 2);
                        output[op] = (byte) (value >> 10);
                        op += 2;
                        state = 5;
                    } else if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;

                case 4:
                    if (d == EQUALS) {
                        ++state;
                    } else if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;

                case 5:
                    if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;
                }
            }

            if (!finish) {
                // We're out of input, but a future call could provide
                // more.
                this.state = state;
                this.value = value;
                this.op = op;
                return true;
            }

            // Done reading input.  Now figure out where we are left in
            // the state machine and finish up.

            switch (state) {
            case 0:
                // Output length is a multiple of three.  Fine.
                break;
            case 1:
                // Read one extra input byte, which isn't enough to
                // make another output byte.  Illegal.
                this.state = 6;
                return false;
            case 2:
                // Read two extra input bytes, enough to emit 1 more
                // output byte.  Fine.
                output[op++] = (byte) (value >> 4);
                break;
            case 3:
                // Read three extra input bytes, enough to emit 2 more
                // output bytes.  Fine.
                output[op++] = (byte) (value >> 10);
                output[op++] = (byte) (value >> 2);
                break;
            case 4:
                // Read one padding '=' when we expected 2.  Illegal.
                this.state = 6;
                return false;
            case 5:
                // Read all the padding '='s we expected and no more.
                // Fine.
                break;
            }

            this.state = state;
            this.op = op;
            return true;
        }
    }

    //  --------------------------------------------------------
    //  encoding
    //  --------------------------------------------------------

    /**
     * Base64-encode the given data and return a newly allocated
     * String with the result.
     *
     * @param input  the data to encode
     * @param flags  controls certain features of the encoded output.
     *               Passing {@code DEFAULT} results in output that
     *               adheres to RFC 2045.
     */
    public static String encodeToString(byte[] input, int flags) {
        try {
            return new String(encode(input, flags), "US-ASCII");
        } catch (UnsupportedEncodingException e) {
            // US-ASCII is guaranteed to be available.
            throw new AssertionError(e);
        }
    }

    /**
     * Base64-encode the given data and return a newly allocated
     * String with the result.
     *
     * @param input  the data to encode
     * @param offset the position within the input array at which to
     *               start
     * @param len    the number of bytes of input to encode
     * @param flags  controls certain features of the encoded output.
     *               Passing {@code DEFAULT} results in output that
     *               adheres to RFC 2045.
     */
    public static String encodeToString(byte[] input, int offset, int len, int flags) {
        try {
            return new String(encode(input, offset, len, flags), "US-ASCII");
        } catch (UnsupportedEncodingException e) {
            // US-ASCII is guaranteed to be available.
            throw new AssertionError(e);
        }
    }

    /**
     * Base64-encode the given data and return a newly allocated
     * byte[] with the result.
     *
     * @param input  the data to encode
     * @param flags  controls certain features of the encoded output.
     *               Passing {@code DEFAULT} results in output that
     *               adheres to RFC 2045.
     */
    public static byte[] encode(byte[] input, int flags) {
        return encode(input, 0, input.length, flags);
    }

    /**
     * Base64-encode the given data and return a newly allocated
     * byte[] with the result.
     *
     * @param input  the data to encode
     * @param offset the position within the input array at which to
     *               start
     * @param len    the number of bytes of input to encode
     * @param flags  controls certain features of the encoded output.
     *               Passing {@code DEFAULT} results in output that
     *               adheres to RFC 2045.
     */
    public static byte[] encode(byte[] input, int offset, int len, int flags) {
        Encoder encoder = new Encoder(flags, null);

        // Compute the exact length of the array we will produce.
        int output_len = len / 3 * 4;

        // Account for the tail of the data and the padding bytes, if any.
        if (encoder.do_padding) {
            if (len % 3 > 0) {
                output_len += 4;
            }
        } else {
            switch (len % 3) {
                case 0: break;
                case 1: output_len += 2; break;
                case 2: output_len += 3; break;
            }
        }

        // Account for the newlines, if any.
        if (encoder.do_newline && len > 0) {
            output_len += (((len-1) / (3 * Encoder.LINE_GROUPS)) + 1) *
                (encoder.do_cr ? 2 : 1);
        }

        encoder.output = new byte[output_len];
        encoder.process(input, offset, len, true);

        assert encoder.op == output_len;

        return encoder.output;
    }

    /* package */ static class Encoder extends Coder {
        /**
         * Emit a new line every this many output tuples.  Corresponds to
         * a 76-character line length (the maximum allowable according to
         * <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045</a>).
         */
        public static final int LINE_GROUPS = 19;

        /**
         * Lookup table for turning Base64 alphabet positions (6 bits)
         * into output bytes.
         */
        private static final byte ENCODE[] = {
            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
            'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
            'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
            'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/',
        };

        /**
         * Lookup table for turning Base64 alphabet positions (6 bits)
         * into output bytes.
         */
        private static final byte ENCODE_WEBSAFE[] = {
            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
            'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
            'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
            'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_',
        };

        final private byte[] tail;
        /* package */ int tailLen;
        private int count;

        final public boolean do_padding;
        final public boolean do_newline;
        final public boolean do_cr;
        final private byte[] alphabet;

        public Encoder(int flags, byte[] output) {
            this.output = output;

            do_padding = (flags & NO_PADDING) == 0;
            do_newline = (flags & NO_WRAP) == 0;
            do_cr = (flags & CRLF) != 0;
            alphabet = ((flags & URL_SAFE) == 0) ? ENCODE : ENCODE_WEBSAFE;

            tail = new byte[2];
            tailLen = 0;

            count = do_newline ? LINE_GROUPS : -1;
        }

        /**
         * @return an overestimate for the number of bytes {@code
         * len} bytes could encode to.
         */
        public int maxOutputSize(int len) {
            return len * 8/5 + 10;
        }

        public boolean process(byte[] input, int offset, int len, boolean finish) {
            // Using local variables makes the encoder about 9% faster.
            final byte[] alphabet = this.alphabet;
            final byte[] output = this.output;
            int op = 0;
            int count = this.count;

            int p = offset;
            len += offset;
            int v = -1;

            // First we need to concatenate the tail of the previous call
            // with any input bytes available now and see if we can empty
            // the tail.

            switch (tailLen) {
                case 0:
                    // There was no tail.
                    break;

                case 1:
                    if (p+2 <= len) {
                        // A 1-byte tail with at least 2 bytes of
                        // input available now.
                        v = ((tail[0] & 0xff) << 16) |
                            ((input[p++] & 0xff) << 8) |
                            (input[p++] & 0xff);
                        tailLen = 0;
                    };
                    break;

                case 2:
                    if (p+1 <= len) {
                        // A 2-byte tail with at least 1 byte of input.
                        v = ((tail[0] & 0xff) << 16) |
                            ((tail[1] & 0xff) << 8) |
                            (input[p++] & 0xff);
                        tailLen = 0;
                    }
                    break;
            }

            if (v != -1) {
                output[op++] = alphabet[(v >> 18) & 0x3f];
                output[op++] = alphabet[(v >> 12) & 0x3f];
                output[op++] = alphabet[(v >> 6) & 0x3f];
                output[op++] = alphabet[v & 0x3f];
                if (--count == 0) {
                    if (do_cr) output[op++] = '\r';
                    output[op++] = '\n';
                    count = LINE_GROUPS;
                }
            }

            // At this point either there is no tail, or there are fewer
            // than 3 bytes of input available.

            // The main loop, turning 3 input bytes into 4 output bytes on
            // each iteration.
            while (p+3 <= len) {
                v = ((input[p] & 0xff) << 16) |
                    ((input[p+1] & 0xff) << 8) |
                    (input[p+2] & 0xff);
                output[op] = alphabet[(v >> 18) & 0x3f];
                output[op+1] = alphabet[(v >> 12) & 0x3f];
                output[op+2] = alphabet[(v >> 6) & 0x3f];
                output[op+3] = alphabet[v & 0x3f];
                p += 3;
                op += 4;
                if (--count == 0) {
                    if (do_cr) output[op++] = '\r';
                    output[op++] = '\n';
                    count = LINE_GROUPS;
                }
            }

            if (finish) {
                // Finish up the tail of the input.  Note that we need to
                // consume any bytes in tail before any bytes
                // remaining in input; there should be at most two bytes
                // total.

                if (p-tailLen == len-1) {
                    int t = 0;
                    v = ((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 4;
                    tailLen -= t;
                    output[op++] = alphabet[(v >> 6) & 0x3f];
                    output[op++] = alphabet[v & 0x3f];
                    if (do_padding) {
                        output[op++] = '=';
                        output[op++] = '=';
                    }
                    if (do_newline) {
                        if (do_cr) output[op++] = '\r';
                        output[op++] = '\n';
                    }
                } else if (p-tailLen == len-2) {
                    int t = 0;
                    v = (((tailLen > 1 ? tail[t++] : input[p++]) & 0xff) << 10) |
                        (((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 2);
                    tailLen -= t;
                    output[op++] = alphabet[(v >> 12) & 0x3f];
                    output[op++] = alphabet[(v >> 6) & 0x3f];
                    output[op++] = alphabet[v & 0x3f];
                    if (do_padding) {
                        output[op++] = '=';
                    }
                    if (do_newline) {
                        if (do_cr) output[op++] = '\r';
                        output[op++] = '\n';
                    }
                } else if (do_newline && op > 0 && count != LINE_GROUPS) {
                    if (do_cr) output[op++] = '\r';
                    output[op++] = '\n';
                }

                assert tailLen == 0;
                assert p == len;
            } else {
                // Save the leftovers in tail to be consumed on the next
                // call to encodeInternal.

                if (p == len-1) {
                    tail[tailLen++] = input[p];
                } else if (p == len-2) {
                    tail[tailLen++] = input[p];
                    tail[tailLen++] = input[p+1];
                }
            }

            this.op = op;
            this.count = count;

            return true;
        }
    }

    private Base64() { }   // don't instantiate
}
-------
package nike.akamai;

import android.os.SystemClock;
import android.view.MotionEvent;
import android.view.View;
import com.alibaba.fastjson.JSONArray;
import com.alibaba.fastjson.JSONObject;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class Utils {

    public static JSONObject simpleJSON(Object... kvs) {
        if (kvs == null || kvs.length % 2 != 0) {
            return null;
        }
        JSONObject json = new JSONObject();
        String key = null;
        for (int i = 0; i < kvs.length; i++) {
            Object data = kvs[i];
            if (i % 2 == 0) {
                key = data.toString();
            } else {
                json.put(key, data);
            }
        }
        return json;
    }

    public static JSONArray simpleJSONArray(Object... objs) {
        JSONArray arr = new JSONArray();
        for (Object obj : objs) {
            arr.add(obj);
        }
        return arr;
    }

    public static String md5(String data) {
        return md5(data.getBytes());
    }

    public static String md5(byte[] data) {
        MessageDigest md = null;
        try {
            md = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        md.update(data);
        byte[] digest = md.digest();
        BigInteger no = new BigInteger(1, digest);

        String hashtext = no.toString(16);
        while (hashtext.length() < 32) {
            hashtext = "0" + hashtext;
        }
        return hashtext;
    }

    public static byte[] consumeInputStream(InputStream inputStream) throws IOException {
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        byte[] buffer = new byte[1024];
        for (int count; (count = inputStream.read(buffer)) != -1; ) {
            byteArrayOutputStream.write(buffer, 0, count);
        }
        return byteArrayOutputStream.toByteArray();
    }

    public static void simulateTouchEvent(View view, float x, float y) {
        long downTime = SystemClock.uptimeMillis();
        long eventTime = SystemClock.uptimeMillis() + 100;
        int metaState = 0;
        MotionEvent motionEvent = MotionEvent.obtain(downTime, eventTime,
                MotionEvent.ACTION_DOWN, x, y, metaState);
        view.dispatchTouchEvent(motionEvent);
        MotionEvent upEvent = MotionEvent.obtain(downTime + 100, eventTime + 100,
                MotionEvent.ACTION_UP, x,y, metaState);
        view.dispatchTouchEvent(upEvent);
    }
}


